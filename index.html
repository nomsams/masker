<!-- 
LASSOMASK STUDIO ULTIMATE v3.5 - VC DEMO BUILD
---------------------------------------------------
USER INSTRUCTIONS:

1.  **Navigation**:
    -   **Zoom**: Mouse Wheel or UI Buttons.
    -   **Pan**: Hold SPACE + Drag, or Middle Mouse Button.

2.  **Drawing**:
    -   **Freehand**: Click and Drag.
    -   **Polyline**: Click, move, click again.
    -   **Close Loop**: Click the Green Start Point or Double Click.

3.  **Accessibility & Visualization**:
    -   **Pattern Mode**: Toggle "Pattern Fill" to use geometric textures (stripes, dots) instead of just solid colors. Ideal for color blindness.
    -   **Legend Mode**: Switch Label Style to "Legend Box" to see a MATLAB-style list in the corner.

4.  **Organization**:
    -   **Siblings**: Right-click an area -> "Add Sibling" to add disconnected parts to the same group.
    -   **Auto-Color**: Colors cycle automatically.

5.  **Export**:
    -   **Export Result**: Downloads full-res PNG with masks, patterns, and legend burned in.
    -   **Export JSON**: Data for ML training.

6.  **Shortcuts**:
    -   `Ctrl+Z`: Undo
    -   `Space`: Pan
    -   `[` / `]`: Brush Size
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LassoMask Studio Ultimate v3.5</title>
    <style>
        /* ------------------------------------------------------------------
           THEME & VARIABLES
           ------------------------------------------------------------------ */
        :root {
            --bg-app: #f8fafc;
            --bg-panel: #ffffff;
            --bg-canvas: #e2e8f0;
            --text-main: #0f172a;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --danger: #ef4444;
            
            --header-h: 60px;
            --sidebar-w: 320px;
            --radius: 8px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --font: 'Inter', system-ui, sans-serif;
        }

        [data-theme="dark"] {
            --bg-app: #0f172a;
            --bg-panel: #1e293b;
            --bg-canvas: #020617;
            --text-main: #f1f5f9;
            --text-muted: #94a3b8;
            --border: #334155;
            --primary: #60a5fa;
            --primary-hover: #3b82f6;
        }

        * { box-sizing: border-box; outline: none; user-select: none; }
        
        body {
            margin: 0;
            font-family: var(--font);
            background: var(--bg-app);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ------------------------------------------------------------------
           UI COMPONENTS
           ------------------------------------------------------------------ */
        header {
            height: var(--header-h);
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            z-index: 20;
            box-shadow: var(--shadow);
        }

        .logo { font-weight: 800; font-size: 1.25rem; display: flex; align-items: center; gap: 10px; letter-spacing: -0.025em; }
        .logo span { color: var(--primary); }
        .version-tag { font-size: 0.7rem; background: var(--bg-app); padding: 2px 8px; border-radius: 12px; color: var(--text-muted); border: 1px solid var(--border); font-weight: 600; }

        .toolbar { display: flex; gap: 8px; align-items: center; }

        .btn {
            padding: 8px 16px;
            border-radius: var(--radius);
            border: 1px solid transparent;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        .btn-primary { background: var(--primary); color: white; box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3); }
        .btn-primary:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .btn-sec { background: transparent; border-color: var(--border); color: var(--text-main); }
        .btn-sec:hover { background: var(--bg-app); }
        .btn-icon { padding: 8px; border-radius: 50%; color: var(--text-muted); background: transparent; border: none; cursor: pointer; }
        .btn-icon:hover { background: var(--bg-app); color: var(--text-main); }
        .btn-icon.active { background: var(--primary); color: white; }

        aside {
            width: var(--sidebar-w);
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .panel-section { padding: 1.25rem; border-bottom: 1px solid var(--border); }
        .panel-title { font-size: 0.7rem; text-transform: uppercase; color: var(--text-muted); font-weight: 700; margin-bottom: 1rem; letter-spacing: 0.05em; }

        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; }
        .control-row label { font-size: 0.85rem; font-weight: 500; }
        
        input[type="range"] { width: 120px; accent-color: var(--primary); }
        input[type="color"] { border: none; width: 32px; height: 32px; cursor: pointer; background: none; border-radius: 4px; }
        select { background: var(--bg-app); border: 1px solid var(--border); color: var(--text-main); padding: 6px; border-radius: 6px; font-size: 0.85rem; }

        /* Toggle Switch */
        .toggle-switch { position: relative; width: 40px; height: 22px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; inset: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(18px); }

        .layer-list { flex: 1; overflow-y: auto; padding: 0.5rem; }
        .layer-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: var(--bg-app);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            margin-bottom: 8px;
            cursor: pointer;
            transition: 0.2s;
        }
        .layer-item:hover { border-color: var(--primary); }
        .layer-item.selected { background: rgba(59, 130, 246, 0.08); border-color: var(--primary); }
        .layer-dot { width: 14px; height: 14px; border-radius: 4px; margin-right: 12px; border: 1px solid rgba(0,0,0,0.1); }
        .layer-name { flex: 1; font-size: 0.9rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        main { flex: 1; position: relative; background: var(--bg-canvas); overflow: hidden; display: flex; }
        
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas { display: block; transform-origin: 0 0; }

        .overlay-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: var(--text-muted); pointer-events: none;
        }
        
        #floating-input {
            position: absolute; display: none; z-index: 100;
            background: var(--bg-panel); padding: 8px; border-radius: var(--radius);
            box-shadow: var(--shadow); border: 1px solid var(--primary);
            animation: popIn 0.2s ease;
        }
        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #context-menu {
            position: absolute; display: none; z-index: 200;
            background: var(--bg-panel); border: 1px solid var(--border);
            border-radius: var(--radius); box-shadow: var(--shadow);
            min-width: 160px; flex-direction: column; padding: 4px;
        }
        .ctx-btn {
            padding: 8px 12px; text-align: left; background: none; border: none;
            color: var(--text-main); font-size: 0.85rem; cursor: pointer; border-radius: 4px;
            display: flex; align-items: center; gap: 8px;
        }
        .ctx-btn:hover { background: var(--bg-app); }
        .ctx-btn.danger { color: var(--danger); }

        .zoom-controls {
            position: absolute; bottom: 20px; right: 20px;
            background: var(--bg-panel); border: 1px solid var(--border);
            border-radius: var(--radius); display: flex; gap: 1px;
            box-shadow: var(--shadow);
        }
        .zoom-btn { padding: 8px 12px; background: transparent; border: none; cursor: pointer; color: var(--text-main); }
        .zoom-btn:hover { background: var(--bg-app); }

        .status-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 6px 16px;
            border-radius: 20px; font-size: 0.8rem; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
        }
        .status-bar.show { opacity: 1; }

    </style>
</head>
<body>

    <header>
        <div class="logo">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--primary)" stroke-width="2.5"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
            LassoMask <span>Studio</span> <span class="version-tag">v3.5</span>
        </div>
        <div class="toolbar">
            <button class="btn-icon" id="undo-btn" title="Undo (Ctrl+Z)">‚Ü©</button>
            <button class="btn-icon" id="redo-btn" title="Redo (Ctrl+Y)">‚Ü™</button>
            <div style="width:1px; height:20px; background:var(--border); margin:0 8px;"></div>
            <button class="btn btn-sec" id="theme-btn">üåô</button>
            <button class="btn btn-primary" id="export-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                Export Result
            </button>
            <button class="btn btn-sec" id="export-json-btn">JSON</button>
        </div>
    </header>

    <div style="flex: 1; display: flex; overflow: hidden;">
        <aside>
            <div class="panel-section">
                <div class="panel-title">Tools</div>
                <div class="control-row">
                    <label>Mode</label>
                    <div style="display:flex; gap:4px;">
                        <button class="btn-icon active" id="tool-draw" title="Draw (D)">‚úé</button>
                        <button class="btn-icon" id="tool-pan" title="Pan (Space)">‚úã</button>
                    </div>
                </div>
                <div class="control-row">
                    <label>Pattern Fill (CVD)</label>
                    <label class="toggle-switch" title="Use patterns for color blindness">
                        <input type="checkbox" id="pattern-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-row">
                    <label>Active Color</label>
                    <input type="color" id="color-picker" value="#3b82f6">
                </div>
                <div class="control-row">
                    <label>Stroke Width</label>
                    <input type="range" id="stroke-slider" min="1" max="10" value="2">
                </div>
                <div class="control-row">
                    <label>Opacity</label>
                    <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="0.25">
                </div>
                <div class="control-row">
                    <label>Label Style</label>
                    <select id="label-mode">
                        <option value="inside">Inside (Transparent)</option>
                        <option value="legend">Legend Box (MATLAB)</option>
                    </select>
                </div>
            </div>

            <div class="panel-section" style="flex:1; display:flex; flex-direction:column; padding-bottom:0;">
                <div class="control-row">
                    <div class="panel-title" style="margin:0;">Layers</div>
                    <button class="btn-icon" id="clear-all" style="font-size:0.7rem;">Clear All</button>
                </div>
                <div id="layer-list" class="layer-list"></div>
            </div>

            <div class="panel-section">
                <input type="file" id="file-input" accept="image/*" hidden>
                <button class="btn btn-sec" style="width:100%;" onclick="document.getElementById('file-input').click()">
                    üìÇ Open Image
                </button>
            </div>
        </aside>

        <main>
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
                
                <div class="overlay-msg" id="empty-state">
                    <h3>No Image Loaded</h3>
                    <p>Drag & Drop or Click Open Image</p>
                </div>

                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-out">-</button>
                    <button class="zoom-btn" id="zoom-reset">100%</button>
                    <button class="zoom-btn" id="zoom-in">+</button>
                </div>
            </div>

            <!-- Floating Elements -->
            <div id="floating-input">
                <input type="text" id="label-text" placeholder="Label Name..." style="border:none; outline:none; background:transparent; color:var(--text-main); font-weight:600;">
                <div style="font-size:0.7rem; color:var(--text-muted); text-align:right; margin-top:4px;">Enter to Save</div>
            </div>

            <div id="context-menu">
                <button class="ctx-btn" id="ctx-sibling">‚ûï Add Sibling Area</button>
                <button class="ctx-btn" id="ctx-delete-pt">‚ùå Delete Vertex</button>
                <div style="height:1px; background:var(--border); margin:4px 0;"></div>
                <button class="ctx-btn danger" id="ctx-delete-grp">üóë Delete Group</button>
            </div>

            <div id="status-bar" class="status-bar">Ready</div>
        </main>
    </div>

<script>
/**
 * --------------------------------------------------------------------------
 * CONFIGURATION & PALETTES
 * --------------------------------------------------------------------------
 */
const Config = {
    snapDist: 15,
    vertexRadius: 5,
    hitRadius: 8,
    zoomStep: 0.15,
    minZoom: 0.1,
    maxZoom: 10,
    simplifyEpsilon: 1.5
};

// High contrast palette
const PALETTE = [
    '#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', 
    '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef', '#f43f5e'
];

const State = {
    image: null,
    groups: [], // { id, label, color, paths: [[{x,y}]] }
    
    // Viewport
    scale: 1,
    panX: 0,
    panY: 0,
    
    // Interaction
    tool: 'draw',
    isDragging: false,
    isPanning: false,
    lastMouse: { x: 0, y: 0 },
    
    // Drawing
    activePath: [],
    isDrawing: false,
    addingSiblingTo: null,
    
    // Selection / Editing
    selectedGroupId: null,
    hoveredVertex: null,
    hoveredEdge: null,
    draggingVertex: null,
    
    // History
    history: [],
    historyIdx: -1,

    // Settings
    color: PALETTE[0],
    strokeWidth: 2,
    opacity: 0.25, 
    labelMode: 'inside',
    patternMode: false
};

// DOM Elements
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');
const ui = {
    layerList: document.getElementById('layer-list'),
    floatInput: document.getElementById('floating-input'),
    labelText: document.getElementById('label-text'),
    ctxMenu: document.getElementById('context-menu'),
    statusBar: document.getElementById('status-bar'),
    emptyState: document.getElementById('empty-state'),
    colorPicker: document.getElementById('color-picker')
};

// Pattern Cache
const patternCache = {};

/**
 * --------------------------------------------------------------------------
 * INITIALIZATION
 * --------------------------------------------------------------------------
 */
function init() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Mouse / Touch
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onWheel, { passive: false });
    canvas.addEventListener('contextmenu', onContextMenu);
    
    // Keyboard
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    // UI Bindings
    document.getElementById('file-input').addEventListener('change', e => loadFile(e.target.files[0]));
    document.getElementById('theme-btn').addEventListener('click', toggleTheme);
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('redo-btn').addEventListener('click', redo);
    document.getElementById('export-btn').addEventListener('click', exportImage);
    document.getElementById('export-json-btn').addEventListener('click', exportJSON);
    document.getElementById('clear-all').addEventListener('click', clearAll);
    
    document.getElementById('tool-draw').addEventListener('click', () => setTool('draw'));
    document.getElementById('tool-pan').addEventListener('click', () => setTool('pan'));
    
    document.getElementById('zoom-in').addEventListener('click', () => zoom(1));
    document.getElementById('zoom-out').addEventListener('click', () => zoom(-1));
    document.getElementById('zoom-reset').addEventListener('click', resetView);

    // Settings
    ui.colorPicker.addEventListener('input', e => State.color = e.target.value);
    document.getElementById('stroke-slider').addEventListener('input', e => { State.strokeWidth = parseInt(e.target.value); render(); });
    document.getElementById('opacity-slider').addEventListener('input', e => { State.opacity = parseFloat(e.target.value); render(); });
    document.getElementById('label-mode').addEventListener('change', e => { State.labelMode = e.target.value; render(); });
    document.getElementById('pattern-toggle').addEventListener('change', e => { 
        State.patternMode = e.target.checked; 
        render(); 
    });

    // Context Menu
    document.getElementById('ctx-sibling').addEventListener('click', addSibling);
    document.getElementById('ctx-delete-grp').addEventListener('click', deleteSelected);
    document.getElementById('ctx-delete-pt').addEventListener('click', deleteVertex);

    // Input
    ui.labelText.addEventListener('keydown', e => {
        if(e.key === 'Enter') commitLabel();
        if(e.key === 'Escape') cancelLabel();
    });

    // Drag & Drop
    document.body.addEventListener('dragover', e => e.preventDefault());
    document.body.addEventListener('drop', e => {
        e.preventDefault();
        if(e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
    });

    if(window.matchMedia('(prefers-color-scheme: dark)').matches) toggleTheme();
    
    renderLoop();
}

/**
 * --------------------------------------------------------------------------
 * PATTERN GENERATION (CVD Support)
 * --------------------------------------------------------------------------
 */
function createPattern(color, index) {
    const key = color + index;
    if (patternCache[key]) return patternCache[key];

    const pCanvas = document.createElement('canvas');
    const pCtx = pCanvas.getContext('2d');
    const size = 20;
    pCanvas.width = size;
    pCanvas.height = size;

    // Base transparent background
    pCtx.fillStyle = hexToRgba(color, 0.1); // Very light background
    pCtx.fillRect(0, 0, size, size);

    pCtx.strokeStyle = color;
    pCtx.fillStyle = color;
    pCtx.lineWidth = 2;

    // 6 Distinct Patterns
    const type = index % 6;
    
    pCtx.beginPath();
    if (type === 0) { // Forward Slash
        pCtx.moveTo(0, size); pCtx.lineTo(size, 0);
    } else if (type === 1) { // Back Slash
        pCtx.moveTo(0, 0); pCtx.lineTo(size, size);
    } else if (type === 2) { // Cross
        pCtx.moveTo(0, size/2); pCtx.lineTo(size, size/2);
        pCtx.moveTo(size/2, 0); pCtx.lineTo(size/2, size);
    } else if (type === 3) { // Dots
        pCtx.arc(size/2, size/2, 3, 0, Math.PI*2);
        pCtx.fill();
    } else if (type === 4) { // Horizontal
        pCtx.moveTo(0, size/2); pCtx.lineTo(size, size/2);
    } else if (type === 5) { // Vertical
        pCtx.moveTo(size/2, 0); pCtx.lineTo(size/2, size);
    }
    pCtx.stroke();

    const pattern = ctx.createPattern(pCanvas, 'repeat');
    patternCache[key] = pattern;
    return pattern;
}

/**
 * --------------------------------------------------------------------------
 * INPUT HANDLING
 * --------------------------------------------------------------------------
 */
function onMouseDown(e) {
    if (!State.image) return;
    
    if (e.button === 1 || (State.tool === 'pan' && e.button === 0)) {
        State.isPanning = true;
        State.lastMouse = { x: e.clientX, y: e.clientY };
        container.style.cursor = 'grabbing';
        return;
    }

    if (e.button !== 0) return;

    const pt = getWorldPoint(e);

    // 1. Edit Vertex
    if (State.hoveredVertex) {
        State.draggingVertex = State.hoveredVertex;
        State.selectedGroupId = State.groups[State.hoveredVertex.groupId].id;
        updateLayerUI();
        return;
    }

    // 2. Insert Vertex
    if (State.hoveredEdge && !State.isDrawing) {
        const { groupId, pathIdx, ptIdx } = State.hoveredEdge;
        const group = State.groups[groupId];
        group.paths[pathIdx].splice(ptIdx + 1, 0, pt);
        State.draggingVertex = { groupId, pathIdx, ptIdx: ptIdx + 1 };
        State.selectedGroupId = group.id;
        saveState();
        return;
    }

    // 3. Drawing
    if (State.tool === 'draw') {
        if (State.isDrawing) {
            const start = State.activePath[0];
            const dist = Math.hypot(pt.x - start.x, pt.y - start.y);
            const screenDist = dist * State.scale;

            if (State.activePath.length > 2 && screenDist < Config.snapDist) {
                finishPath();
            } else {
                State.activePath.push(pt);
                State.isDragging = true;
            }
        } else {
            const hitGroup = findGroupHit(pt);
            if (hitGroup && !State.isDrawing) {
                State.selectedGroupId = hitGroup.id;
                updateLayerUI();
                render();
            } else {
                State.isDrawing = true;
                State.activePath = [pt];
                State.isDragging = true;
            }
        }
    }
}

function onMouseMove(e) {
    if (!State.image) return;
    const pt = getWorldPoint(e);

    if (State.isPanning) {
        const dx = e.clientX - State.lastMouse.x;
        const dy = e.clientY - State.lastMouse.y;
        State.panX += dx;
        State.panY += dy;
        State.lastMouse = { x: e.clientX, y: e.clientY };
        render();
        return;
    }

    if (State.draggingVertex) {
        const { groupId, pathIdx, ptIdx } = State.draggingVertex;
        State.groups[groupId].paths[pathIdx][ptIdx] = pt;
        render();
        return;
    }

    if (State.isDrawing && State.isDragging) {
        const last = State.activePath[State.activePath.length - 1];
        if (Math.hypot(pt.x - last.x, pt.y - last.y) > 2 / State.scale) {
            State.activePath.push(pt);
        }
        render();
        return;
    }

    updateHoverState(pt);
}

function onMouseUp(e) {
    State.isPanning = false;
    container.style.cursor = State.tool === 'pan' ? 'grab' : 'crosshair';

    if (State.draggingVertex) {
        State.draggingVertex = null;
        saveState();
    }

    if (State.isDrawing && State.isDragging) {
        State.isDragging = false;
        if (State.activePath.length > 10) {
            State.activePath = simplifyPath(State.activePath, Config.simplifyEpsilon / State.scale);
        }
        
        const start = State.activePath[0];
        const end = State.activePath[State.activePath.length - 1];
        const dist = Math.hypot(end.x - start.x, end.y - start.y) * State.scale;
        
        if (State.activePath.length > 2 && dist < Config.snapDist) {
            finishPath();
        }
    }
    render();
}

function onWheel(e) {
    if (!State.image) return;
    e.preventDefault();
    const zoomDir = e.deltaY > 0 ? -1 : 1;
    zoom(zoomDir, e.clientX, e.clientY);
}

function onKeyDown(e) {
    if (e.target.tagName === 'INPUT') return;
    
    if (e.code === 'Space') {
        if (!State.isPanning) {
            State.prevTool = State.tool;
            setTool('pan');
        }
    }
    if (e.key === 'Escape') {
        if (State.isDrawing) {
            State.isDrawing = false;
            State.activePath = [];
            render();
        } else {
            ui.ctxMenu.style.display = 'none';
        }
    }
    if (e.key === 'Enter' && State.isDrawing) finishPath();
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
    if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
    if (e.key === '[') { State.strokeWidth = Math.max(1, State.strokeWidth - 1); render(); }
    if (e.key === ']') { State.strokeWidth = Math.min(20, State.strokeWidth + 1); render(); }
}

function onKeyUp(e) {
    if (e.code === 'Space' && State.prevTool) {
        setTool(State.prevTool);
        State.prevTool = null;
    }
}

/**
 * --------------------------------------------------------------------------
 * LOGIC: DRAWING & EDITING
 * --------------------------------------------------------------------------
 */
function finishPath() {
    if (State.activePath.length < 3) return;
    State.activePath.push({ ...State.activePath[0] }); // Close loop
    
    if (State.addingSiblingTo) {
        const group = State.groups.find(g => g.id === State.addingSiblingTo);
        if (group) {
            group.paths.push([...State.activePath]);
            saveState();
            showStatus("Sibling area added");
        }
        State.addingSiblingTo = null;
        State.isDrawing = false;
        State.activePath = [];
        render();
    } else {
        showLabelInput();
    }
}

function showLabelInput() {
    const center = getCentroid(State.activePath);
    const screen = getScreenPoint(center.x, center.y);
    
    ui.floatInput.style.display = 'block';
    ui.floatInput.style.left = screen.x + 'px';
    ui.floatInput.style.top = screen.y + 'px';
    
    ui.labelText.value = `Object ${State.groups.length + 1}`;
    ui.labelText.focus();
    ui.labelText.select();
}

function commitLabel() {
    const label = ui.labelText.value.trim() || "Untitled";
    
    // Auto-pick color
    const nextColor = PALETTE[State.groups.length % PALETTE.length];
    State.color = nextColor;
    ui.colorPicker.value = nextColor;

    const newGroup = {
        id: Date.now().toString(),
        label: label,
        color: nextColor,
        paths: [[...State.activePath]]
    };
    
    State.groups.push(newGroup);
    State.selectedGroupId = newGroup.id;
    State.isDrawing = false;
    State.activePath = [];
    
    ui.floatInput.style.display = 'none';
    saveState();
    updateLayerUI();
    render();
}

function cancelLabel() {
    State.isDrawing = false;
    State.activePath = [];
    ui.floatInput.style.display = 'none';
    render();
}

function addSibling() {
    ui.ctxMenu.style.display = 'none';
    if (!State.selectedGroupId) return;
    State.addingSiblingTo = State.selectedGroupId;
    State.isDrawing = true;
    State.activePath = [];
    showStatus("Draw new area to add to group");
}

function deleteSelected() {
    if (!State.selectedGroupId) return;
    if (confirm("Delete selected group?")) {
        State.groups = State.groups.filter(g => g.id !== State.selectedGroupId);
        State.selectedGroupId = null;
        saveState();
        updateLayerUI();
        render();
    }
}

function deleteVertex() {
    ui.ctxMenu.style.display = 'none';
    if (State.hoveredVertex) {
        const { groupId, pathIdx, ptIdx } = State.hoveredVertex;
        const path = State.groups[groupId].paths[pathIdx];
        if (path.length > 3) {
            path.splice(ptIdx, 1);
            saveState();
            render();
        } else {
            showStatus("Cannot delete: Path too short");
        }
    }
}

/**
 * --------------------------------------------------------------------------
 * RENDERING
 * --------------------------------------------------------------------------
 */
function renderLoop() {
    requestAnimationFrame(renderLoop);
}

function render(targetCtx = ctx, isExport = false) {
    const w = isExport ? State.image.width : canvas.width;
    const h = isExport ? State.image.height : canvas.height;

    // Reset Transform
    targetCtx.setTransform(1, 0, 0, 1, 0, 0);
    targetCtx.clearRect(0, 0, w, h);
    
    // Apply Transform (only for screen render)
    if (!isExport) {
        targetCtx.setTransform(State.scale, 0, 0, State.scale, State.panX, State.panY);
    }

    // 1. Draw Image
    if (State.image) {
        targetCtx.drawImage(State.image, 0, 0);
    }

    // 2. Draw Groups
    State.groups.forEach((group, index) => {
        const isSelected = !isExport && group.id === State.selectedGroupId;
        
        // Determine Fill Style (Solid or Pattern)
        let fillStyle;
        if (State.patternMode) {
            fillStyle = createPattern(group.color, index);
        } else {
            fillStyle = hexToRgba(group.color, State.opacity);
        }

        targetCtx.fillStyle = fillStyle;
        targetCtx.strokeStyle = isSelected ? '#fff' : group.color;
        targetCtx.lineWidth = (State.strokeWidth) / (isExport ? 1 : State.scale);

        group.paths.forEach(path => {
            targetCtx.beginPath();
            targetCtx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) targetCtx.lineTo(path[i].x, path[i].y);
            targetCtx.closePath();
            targetCtx.fill();
            targetCtx.stroke();
            
            if (isSelected) {
                targetCtx.strokeStyle = group.color;
                targetCtx.setLineDash([5 / State.scale, 5 / State.scale]);
                targetCtx.stroke();
                targetCtx.setLineDash([]);
                
                // Vertices
                targetCtx.fillStyle = '#fff';
                const r = Config.vertexRadius / State.scale;
                for (let p of path) {
                    targetCtx.beginPath();
                    targetCtx.arc(p.x, p.y, r, 0, Math.PI*2);
                    targetCtx.fill();
                    targetCtx.stroke();
                }
            }
        });

        // Labels (Inside Mode)
        if (State.labelMode === 'inside' && group.paths.length > 0) {
            drawInsideLabel(targetCtx, group, isExport);
        }
    });

    // 3. Legend (MATLAB Mode)
    if (State.labelMode === 'legend' && State.groups.length > 0) {
        drawLegend(targetCtx, isExport);
    }

    // 4. Active Path (Screen only)
    if (!isExport && State.activePath.length > 0) {
        targetCtx.beginPath();
        targetCtx.moveTo(State.activePath[0].x, State.activePath[0].y);
        for (let i = 1; i < State.activePath.length; i++) targetCtx.lineTo(State.activePath[i].x, State.activePath[i].y);
        
        targetCtx.strokeStyle = State.color;
        targetCtx.lineWidth = State.strokeWidth / State.scale;
        targetCtx.stroke();

        // Start Point
        const start = State.activePath[0];
        targetCtx.beginPath();
        targetCtx.arc(start.x, start.y, (Config.snapDist / State.scale), 0, Math.PI*2);
        targetCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
        targetCtx.fill();
    }

    // 5. Hover (Screen only)
    if (!isExport && State.hoveredVertex) {
        const { groupId, pathIdx, ptIdx } = State.hoveredVertex;
        const pt = State.groups[groupId].paths[pathIdx][ptIdx];
        targetCtx.beginPath();
        targetCtx.arc(pt.x, pt.y, (Config.vertexRadius + 2) / State.scale, 0, Math.PI*2);
        targetCtx.fillStyle = 'red';
        targetCtx.fill();
    }
}

function drawInsideLabel(ctx, group, isExport) {
    let path = group.paths.reduce((a, b) => a.length > b.length ? a : b);
    const center = getCentroid(path);
    const scale = isExport ? 1 : State.scale;
    
    ctx.font = `bold ${14 / scale}px sans-serif`;
    const text = group.label;
    const metrics = ctx.measureText(text);
    const padding = 6 / scale;
    const w = metrics.width + (padding * 2);
    const h = 24 / scale;
    
    const x = center.x;
    const y = center.y;

    // Transparent Background Box
    ctx.fillStyle = "rgba(255, 255, 255, 0.6)"; // Semi-transparent
    ctx.fillRect(x - w/2, y - h/2, w, h);

    // Border
    ctx.strokeStyle = group.color;
    ctx.lineWidth = 1.5 / scale;
    ctx.strokeRect(x - w/2, y - h/2, w, h);

    // Text
    ctx.fillStyle = "#000";
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);
}

function drawLegend(ctx, isExport) {
    // Reset transform to draw in screen coordinates (or image coordinates for export)
    // For export, we draw relative to image size. For screen, relative to viewport?
    // Actually, for export consistency, let's draw it in "World Space" but fixed to the top-right corner of the image.
    
    const scale = isExport ? 1 : State.scale;
    const fontSize = 14 / scale;
    const padding = 10 / scale;
    const lineHeight = 24 / scale;
    const boxWidth = 150 / scale; // Approximate
    const boxHeight = (State.groups.length * lineHeight) + (padding * 2);
    
    // Position: Top Right of the Image
    const x = State.image.width - boxWidth - (20 / scale);
    const y = 20 / scale;

    // Legend Background
    ctx.fillStyle = `rgba(255, 255, 255, ${State.opacity + 0.5})`; // Slightly more opaque than fills
    ctx.fillRect(x, y, boxWidth, boxHeight);
    ctx.strokeStyle = "#999";
    ctx.lineWidth = 1 / scale;
    ctx.strokeRect(x, y, boxWidth, boxHeight);

    // Items
    ctx.font = `${fontSize}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    State.groups.forEach((g, i) => {
        const rowY = y + padding + (i * lineHeight) + (lineHeight/2) - (padding/2);
        
        // Color Box
        const boxSize = 14 / scale;
        
        if (State.patternMode) {
            ctx.fillStyle = createPattern(g.color, i);
        } else {
            ctx.fillStyle = g.color;
        }
        
        ctx.fillRect(x + padding, rowY - boxSize/2, boxSize, boxSize);
        ctx.strokeRect(x + padding, rowY - boxSize/2, boxSize, boxSize);

        // Text
        ctx.fillStyle = "#000";
        ctx.fillText(g.label, x + padding + boxSize + (8/scale), rowY);
    });
}

/**
 * --------------------------------------------------------------------------
 * HELPERS
 * --------------------------------------------------------------------------
 */
function getWorldPoint(e) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: (e.clientX - rect.left - State.panX) / State.scale,
        y: (e.clientY - rect.top - State.panY) / State.scale
    };
}

function getScreenPoint(wx, wy) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: (wx * State.scale) + State.panX + rect.left,
        y: (wy * State.scale) + State.panY + rect.top
    };
}

function updateHoverState(pt) {
    State.hoveredVertex = null;
    State.hoveredEdge = null;
    
    if (!State.selectedGroupId) return;
    
    const group = State.groups.find(g => g.id === State.selectedGroupId);
    if (!group) return;

    const hitDist = Config.hitRadius / State.scale;

    // Check Vertices
    for (let i = 0; i < group.paths.length; i++) {
        const path = group.paths[i];
        for (let j = 0; j < path.length; j++) {
            if (Math.hypot(pt.x - path[j].x, pt.y - path[j].y) < hitDist) {
                State.hoveredVertex = { groupId: State.groups.indexOf(group), pathIdx: i, ptIdx: j };
                container.style.cursor = 'move';
                render();
                return;
            }
        }
    }

    // Check Edges
    for (let i = 0; i < group.paths.length; i++) {
        const path = group.paths[i];
        for (let j = 0; j < path.length; j++) {
            const p1 = path[j];
            const p2 = path[(j + 1) % path.length];
            const dist = distToSegment(pt, p1, p2);
            if (dist < hitDist) {
                State.hoveredEdge = { groupId: State.groups.indexOf(group), pathIdx: i, ptIdx: j };
                container.style.cursor = 'copy';
                render();
                return;
            }
        }
    }
    
    container.style.cursor = State.tool === 'pan' ? 'grab' : 'crosshair';
    render();
}

function distToSegment(p, v, w) {
    const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
    if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
}

function findGroupHit(pt) {
    for (let i = State.groups.length - 1; i >= 0; i--) {
        const group = State.groups[i];
        for (let path of group.paths) {
            if (pointInPoly(pt, path)) return group;
        }
    }
    return null;
}

function pointInPoly(p, vs) {
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        let xi = vs[i].x, yi = vs[i].y;
        let xj = vs[j].x, yj = vs[j].y;
        let intersect = ((yi > p.y) != (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

function getCentroid(path) {
    let x = 0, y = 0;
    path.forEach(p => { x += p.x; y += p.y; });
    return { x: x / path.length, y: y / path.length };
}

function simplifyPath(points, epsilon) {
    if (points.length <= 2) return points;
    let dmax = 0, index = 0;
    const end = points.length - 1;
    for (let i = 1; i < end; i++) {
        const d = distToSegment(points[i], points[0], points[end]);
        if (d > dmax) { index = i; dmax = d; }
    }
    if (dmax > epsilon) {
        const res1 = simplifyPath(points.slice(0, index + 1), epsilon);
        const res2 = simplifyPath(points.slice(index), epsilon);
        return res1.slice(0, res1.length - 1).concat(res2);
    }
    return [points[0], points[end]];
}

/**
 * --------------------------------------------------------------------------
 * FILE & EXPORT
 * --------------------------------------------------------------------------
 */
function loadFile(file) {
    if (!file.type.startsWith('image/')) return alert("Not an image");
    const reader = new FileReader();
    reader.onload = e => {
        const img = new Image();
        img.onload = () => {
            State.image = img;
            State.groups = [];
            State.history = [];
            resetView();
            ui.emptyState.style.display = 'none';
            updateLayerUI();
            render();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function exportJSON() {
    if (!State.image) return;
    const data = {
        version: "3.5",
        image: State.image.src.substring(0, 50) + "...",
        width: State.image.width,
        height: State.image.height,
        annotations: State.groups.map(g => ({
            label: g.label,
            color: g.color,
            polygons: g.paths
        }))
    };
    const jsonBlob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(jsonBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "annotations.json";
    a.click();
}

function exportImage() {
    if (!State.image) return;
    
    // Create temp canvas at full image resolution
    const tCanvas = document.createElement('canvas');
    tCanvas.width = State.image.width;
    tCanvas.height = State.image.height;
    const tCtx = tCanvas.getContext('2d');
    
    // Render clean version (isExport = true)
    render(tCtx, true);
    
    const link = document.createElement('a');
    link.download = 'annotated_image.png';
    link.href = tCanvas.toDataURL('image/png');
    link.click();
}

/**
 * --------------------------------------------------------------------------
 * UI UPDATES & UTILS
 * --------------------------------------------------------------------------
 */
function updateLayerUI() {
    ui.layerList.innerHTML = '';
    State.groups.slice().reverse().forEach(g => {
        const el = document.createElement('div');
        el.className = `layer-item ${g.id === State.selectedGroupId ? 'selected' : ''}`;
        el.innerHTML = `
            <div class="layer-dot" style="background:${g.color}"></div>
            <div class="layer-name">${g.label}</div>
            <div style="font-size:0.7rem; color:var(--text-muted)">${g.paths.length}</div>
        `;
        el.onclick = () => {
            State.selectedGroupId = g.id;
            updateLayerUI();
            render();
        };
        el.oncontextmenu = (e) => {
            e.preventDefault();
            State.selectedGroupId = g.id;
            updateLayerUI();
            onContextMenu(e);
        };
        ui.layerList.appendChild(el);
    });
}

function onContextMenu(e) {
    e.preventDefault();
    ui.ctxMenu.style.display = 'flex';
    ui.ctxMenu.style.left = e.clientX + 'px';
    ui.ctxMenu.style.top = e.clientY + 'px';
}

function zoom(dir, cx, cy) {
    const factor = dir > 0 ? (1 + Config.zoomStep) : (1 - Config.zoomStep);
    const newScale = Math.max(Config.minZoom, Math.min(Config.maxZoom, State.scale * factor));
    
    const rect = canvas.getBoundingClientRect();
    const mx = cx !== undefined ? cx - rect.left : rect.width / 2;
    const my = cy !== undefined ? cy - rect.top : rect.height / 2;

    State.panX = mx - (mx - State.panX) * (newScale / State.scale);
    State.panY = my - (my - State.panY) * (newScale / State.scale);
    State.scale = newScale;
    
    render();
}

function resetView() {
    if (!State.image) return;
    const rect = container.getBoundingClientRect();
    const scaleW = rect.width / State.image.width;
    const scaleH = rect.height / State.image.height;
    State.scale = Math.min(scaleW, scaleH) * 0.9;
    State.panX = (rect.width - State.image.width * State.scale) / 2;
    State.panY = (rect.height - State.image.height * State.scale) / 2;
    render();
}

function resizeCanvas() {
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    render();
}

function setTool(t) {
    State.tool = t;
    document.querySelectorAll('.btn-icon').forEach(b => b.classList.remove('active'));
    document.getElementById(`tool-${t}`).classList.add('active');
    container.style.cursor = t === 'pan' ? 'grab' : 'crosshair';
}

function toggleTheme() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    document.documentElement.setAttribute('data-theme', isDark ? 'light' : 'dark');
    document.getElementById('theme-btn').textContent = isDark ? 'üåô' : '‚òÄ';
}

function showStatus(msg) {
    ui.statusBar.textContent = msg;
    ui.statusBar.classList.add('show');
    setTimeout(() => ui.statusBar.classList.remove('show'), 2000);
}

function saveState() {
    const snapshot = JSON.stringify(State.groups);
    if (State.historyIdx < State.history.length - 1) {
        State.history = State.history.slice(0, State.historyIdx + 1);
    }
    State.history.push(snapshot);
    State.historyIdx++;
    if (State.history.length > 20) { State.history.shift(); State.historyIdx--; }
    localStorage.setItem('lassoData', snapshot);
}

function undo() {
    if (State.historyIdx > 0) {
        State.historyIdx--;
        State.groups = JSON.parse(State.history[State.historyIdx]);
        updateLayerUI();
        render();
        showStatus("Undo");
    }
}

function redo() {
    if (State.historyIdx < State.history.length - 1) {
        State.historyIdx++;
        State.groups = JSON.parse(State.history[State.historyIdx]);
        updateLayerUI();
        render();
        showStatus("Redo");
    }
}

function clearAll() {
    if(confirm("Clear all annotations?")) {
        State.groups = [];
        saveState();
        updateLayerUI();
        render();
    }
}

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// Start
init();

</script>
</body>
</html>

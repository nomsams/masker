<!-- 
LASSOMASK STUDIO ULTIMATE v4.0
---------------------------------------------------
USER INSTRUCTIONS:

1.  **Tools**:
    -   **Lasso (D)**: Standard area selection.
    -   **Arrow (A)**: Draws a smoothed line with an arrowhead at the end.
    -   **Hand (Space)**: Pan the canvas OR Drag Labels to reposition them.

2.  **Drawing Behavior**:
    -   **Hold to Draw**: Enabled by default. Click & Drag to draw, release to finish. 
    -   Disable this in settings to use the old "Click-Click" Polyline mode.

3.  **Labels**:
    -   **Auto-Placement**: Labels inside large areas, outside small areas.
    -   **Manual Placement**: Use the Hand tool to drag a label anywhere.

4.  **Organization**:
    -   **Siblings**: Right-click -> "Add Sibling" to add parts to a group.
    -   **Pattern Mode**: Geometric fills for color blindness.

5.  **Export**:
    -   **Export Result**: PNG with all arrows, labels, and masks burned in.
    -   **Export JSON**: Includes arrow paths and label positions.

6.  **Shortcuts**:
    -   `Ctrl+Z`: Undo
    -   `Space`: Toggle Hand Tool
    -   `[` / `]`: Brush Size
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LassoMask Studio Ultimate v4.0</title>
    <style>
        /* ------------------------------------------------------------------
           THEME & VARIABLES
           ------------------------------------------------------------------ */
        :root {
            --bg-app: #f8fafc;
            --bg-panel: #ffffff;
            --bg-canvas: #e2e8f0;
            --text-main: #0f172a;
            --text-muted: #64748b;
            --border: #cbd5e1;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --danger: #ef4444;
            
            --header-h: 60px;
            --sidebar-w: 320px;
            --radius: 8px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --font: 'Inter', system-ui, sans-serif;
        }

        [data-theme="dark"] {
            --bg-app: #0f172a;
            --bg-panel: #1e293b;
            --bg-canvas: #020617;
            --text-main: #f1f5f9;
            --text-muted: #94a3b8;
            --border: #334155;
            --primary: #60a5fa;
            --primary-hover: #3b82f6;
        }

        * { box-sizing: border-box; outline: none; user-select: none; }
        
        body {
            margin: 0;
            font-family: var(--font);
            background: var(--bg-app);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ------------------------------------------------------------------
           UI COMPONENTS
           ------------------------------------------------------------------ */
        header {
            height: var(--header-h);
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            z-index: 20;
            box-shadow: var(--shadow);
        }

        .logo { font-weight: 800; font-size: 1.25rem; display: flex; align-items: center; gap: 10px; letter-spacing: -0.025em; }
        .logo span { color: var(--primary); }
        .version-tag { font-size: 0.7rem; background: var(--bg-app); padding: 2px 8px; border-radius: 12px; color: var(--text-muted); border: 1px solid var(--border); font-weight: 600; }

        .toolbar { display: flex; gap: 8px; align-items: center; }

        .btn {
            padding: 8px 16px;
            border-radius: var(--radius);
            border: 1px solid transparent;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        .btn-primary { background: var(--primary); color: white; box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3); }
        .btn-primary:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .btn-sec { background: transparent; border-color: var(--border); color: var(--text-main); }
        .btn-sec:hover { background: var(--bg-app); }
        .btn-icon { padding: 8px; border-radius: 6px; color: var(--text-muted); background: transparent; border: 1px solid transparent; cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .btn-icon:hover { background: var(--bg-app); color: var(--text-main); border-color: var(--border); }
        .btn-icon.active { background: var(--primary); color: white; border-color: var(--primary); }

        aside {
            width: var(--sidebar-w);
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .panel-section { padding: 1.25rem; border-bottom: 1px solid var(--border); }
        .panel-title { font-size: 0.7rem; text-transform: uppercase; color: var(--text-muted); font-weight: 700; margin-bottom: 1rem; letter-spacing: 0.05em; }

        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; }
        .control-row label { font-size: 0.85rem; font-weight: 500; }
        
        input[type="range"] { width: 120px; accent-color: var(--primary); }
        input[type="color"] { border: none; width: 32px; height: 32px; cursor: pointer; background: none; border-radius: 4px; }
        select { background: var(--bg-app); border: 1px solid var(--border); color: var(--text-main); padding: 6px; border-radius: 6px; font-size: 0.85rem; }

        /* Toggle Switch */
        .toggle-switch { position: relative; width: 40px; height: 22px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; inset: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(18px); }

        .layer-list { flex: 1; overflow-y: auto; padding: 0.5rem; }
        .layer-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: var(--bg-app);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            margin-bottom: 8px;
            cursor: pointer;
            transition: 0.2s;
        }
        .layer-item:hover { border-color: var(--primary); }
        .layer-item.selected { background: rgba(59, 130, 246, 0.08); border-color: var(--primary); }
        .layer-dot { width: 14px; height: 14px; border-radius: 4px; margin-right: 12px; border: 1px solid rgba(0,0,0,0.1); }
        .layer-name { flex: 1; font-size: 0.9rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        main { flex: 1; position: relative; background: var(--bg-canvas); overflow: hidden; display: flex; }
        
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: crosshair;
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas { display: block; transform-origin: 0 0; }

        .overlay-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: var(--text-muted); pointer-events: none;
        }
        
        #floating-input {
            position: absolute; display: none; z-index: 100;
            background: var(--bg-panel); padding: 8px; border-radius: var(--radius);
            box-shadow: var(--shadow); border: 1px solid var(--primary);
            animation: popIn 0.2s ease;
        }
        @keyframes popIn { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        #context-menu {
            position: absolute; display: none; z-index: 200;
            background: var(--bg-panel); border: 1px solid var(--border);
            border-radius: var(--radius); box-shadow: var(--shadow);
            min-width: 160px; flex-direction: column; padding: 4px;
        }
        .ctx-btn {
            padding: 8px 12px; text-align: left; background: none; border: none;
            color: var(--text-main); font-size: 0.85rem; cursor: pointer; border-radius: 4px;
            display: flex; align-items: center; gap: 8px;
        }
        .ctx-btn:hover { background: var(--bg-app); }
        .ctx-btn.danger { color: var(--danger); }

        .zoom-controls {
            position: absolute; bottom: 20px; right: 20px;
            background: var(--bg-panel); border: 1px solid var(--border);
            border-radius: var(--radius); display: flex; gap: 1px;
            box-shadow: var(--shadow);
        }
        .zoom-btn { padding: 8px 12px; background: transparent; border: none; cursor: pointer; color: var(--text-main); }
        .zoom-btn:hover { background: var(--bg-app); }

        .status-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 6px 16px;
            border-radius: 20px; font-size: 0.8rem; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
        }
        .status-bar.show { opacity: 1; }

    </style>
</head>
<body>

    <header>
        <div class="logo">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--primary)" stroke-width="2.5"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
            LassoMask <span>Studio</span> <span class="version-tag">v4.0</span>
        </div>
        <div class="toolbar">
            <button class="btn-icon" id="undo-btn" title="Undo (Ctrl+Z)">‚Ü©</button>
            <button class="btn-icon" id="redo-btn" title="Redo (Ctrl+Y)">‚Ü™</button>
            <div style="width:1px; height:20px; background:var(--border); margin:0 8px;"></div>
            <button class="btn btn-sec" id="theme-btn">üåô</button>
            <button class="btn btn-primary" id="export-btn">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                Export Result
            </button>
            <button class="btn btn-sec" id="export-json-btn">JSON</button>
        </div>
    </header>

    <div style="flex: 1; display: flex; overflow: hidden;">
        <aside>
            <div class="panel-section">
                <div class="panel-title">Tools</div>
                <div class="control-row">
                    <label>Active Tool</label>
                    <div style="display:flex; gap:4px;">
                        <button class="btn-icon active" id="tool-draw" title="Lasso (D)">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                        </button>
                        <button class="btn-icon" id="tool-arrow" title="Arrow (A)">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg>
                        </button>
                        <button class="btn-icon" id="tool-pan" title="Hand/Move Labels (Space)">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 11V6a2 2 0 00-2-2v0a2 2 0 00-2 2v0"/><path d="M14 10V4a2 2 0 00-2-2v0a2 2 0 00-2 2v2"/><path d="M10 10.5V6a2 2 0 00-2-2v0a2 2 0 00-2 2v8"/><path d="M18 8a2 2 0 114 0v6a8 8 0 01-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 012.83-2.82L7 15"/></svg>
                        </button>
                    </div>
                </div>
                <div class="control-row">
                    <label>Hold to Draw</label>
                    <label class="toggle-switch" title="Release mouse to finish shape">
                        <input type="checkbox" id="hold-draw-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-row">
                    <label>Pattern Fill (CVD)</label>
                    <label class="toggle-switch" title="Use patterns for color blindness">
                        <input type="checkbox" id="pattern-toggle">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-row">
                    <label>Active Color</label>
                    <input type="color" id="color-picker" value="#3b82f6">
                </div>
                <div class="control-row">
                    <label>Stroke Width</label>
                    <input type="range" id="stroke-slider" min="1" max="10" value="2">
                </div>
                <div class="control-row">
                    <label>Opacity</label>
                    <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="0.25">
                </div>
                <div class="control-row">
                    <label>Label Style</label>
                    <select id="label-mode">
                        <option value="inside">Smart Labels</option>
                        <option value="legend">Legend Box</option>
                    </select>
                </div>
            </div>

            <div class="panel-section" style="flex:1; display:flex; flex-direction:column; padding-bottom:0;">
                <div class="control-row">
                    <div class="panel-title" style="margin:0;">Layers</div>
                    <button class="btn-icon" id="clear-all" style="font-size:0.7rem; padding:4px 8px;">Clear All</button>
                </div>
                <div id="layer-list" class="layer-list"></div>
            </div>

            <div class="panel-section">
                <input type="file" id="file-input" accept="image/*" hidden>
                <button class="btn btn-sec" style="width:100%;" onclick="document.getElementById('file-input').click()">
                    üìÇ Open Image
                </button>
            </div>
        </aside>

        <main>
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
                
                <div class="overlay-msg" id="empty-state">
                    <h3>No Image Loaded</h3>
                    <p>Drag & Drop or Click Open Image</p>
                </div>

                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-out">-</button>
                    <button class="zoom-btn" id="zoom-reset">100%</button>
                    <button class="zoom-btn" id="zoom-in">+</button>
                </div>
            </div>

            <!-- Floating Elements -->
            <div id="floating-input">
                <input type="text" id="label-text" placeholder="Label Name..." style="border:none; outline:none; background:transparent; color:var(--text-main); font-weight:600;">
                <div style="font-size:0.7rem; color:var(--text-muted); text-align:right; margin-top:4px;">Enter to Save</div>
            </div>

            <div id="context-menu">
                <button class="ctx-btn" id="ctx-sibling">‚ûï Add Sibling Area</button>
                <button class="ctx-btn" id="ctx-delete-pt">‚ùå Delete Vertex</button>
                <div style="height:1px; background:var(--border); margin:4px 0;"></div>
                <button class="ctx-btn danger" id="ctx-delete-grp">üóë Delete Group</button>
            </div>

            <div id="status-bar" class="status-bar">Ready</div>
        </main>
    </div>

<script>
/**
 * --------------------------------------------------------------------------
 * CONFIGURATION & PALETTES
 * --------------------------------------------------------------------------
 */
const Config = {
    snapDist: 15,
    vertexRadius: 5,
    hitRadius: 8,
    zoomStep: 0.15,
    minZoom: 0.1,
    maxZoom: 10,
    simplifyEpsilon: 1.5
};

const PALETTE = [
    '#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', 
    '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef', '#f43f5e'
];

const State = {
    image: null,
    groups: [], // { id, label, color, type: 'poly'|'arrow', paths: [[{x,y}]], labelPos: {x,y}|null }
    
    // Viewport
    scale: 1,
    panX: 0,
    panY: 0,
    
    // Interaction
    tool: 'draw', // 'draw', 'arrow', 'pan'
    drawBehavior: 'hold', // 'hold', 'click'
    isDragging: false,
    isPanning: false,
    lastMouse: { x: 0, y: 0 },
    
    // Drawing
    activePath: [],
    isDrawing: false,
    addingSiblingTo: null,
    
    // Selection / Editing
    selectedGroupId: null,
    hoveredVertex: null,
    hoveredEdge: null,
    draggingVertex: null,
    draggingLabel: null, // groupId
    
    // History
    history: [],
    historyIdx: -1,

    // Settings
    color: PALETTE[0],
    strokeWidth: 2,
    opacity: 0.25, 
    labelMode: 'inside',
    patternMode: false
};

// DOM Elements
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');
const ui = {
    layerList: document.getElementById('layer-list'),
    floatInput: document.getElementById('floating-input'),
    labelText: document.getElementById('label-text'),
    ctxMenu: document.getElementById('context-menu'),
    statusBar: document.getElementById('status-bar'),
    emptyState: document.getElementById('empty-state'),
    colorPicker: document.getElementById('color-picker')
};

const patternCache = {};

/**
 * --------------------------------------------------------------------------
 * INITIALIZATION
 * --------------------------------------------------------------------------
 */
function init() {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Mouse / Touch
    canvas.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    canvas.addEventListener('wheel', onWheel, { passive: false });
    canvas.addEventListener('contextmenu', onContextMenu);
    
    // Keyboard
    window.addEventListener('keydown', onKeyDown);
    window.addEventListener('keyup', onKeyUp);

    // UI Bindings
    document.getElementById('file-input').addEventListener('change', e => loadFile(e.target.files[0]));
    document.getElementById('theme-btn').addEventListener('click', toggleTheme);
    document.getElementById('undo-btn').addEventListener('click', undo);
    document.getElementById('redo-btn').addEventListener('click', redo);
    document.getElementById('export-btn').addEventListener('click', exportImage);
    document.getElementById('export-json-btn').addEventListener('click', exportJSON);
    document.getElementById('clear-all').addEventListener('click', clearAll);
    
    document.getElementById('tool-draw').addEventListener('click', () => setTool('draw'));
    document.getElementById('tool-arrow').addEventListener('click', () => setTool('arrow'));
    document.getElementById('tool-pan').addEventListener('click', () => setTool('pan'));
    
    document.getElementById('zoom-in').addEventListener('click', () => zoom(1));
    document.getElementById('zoom-out').addEventListener('click', () => zoom(-1));
    document.getElementById('zoom-reset').addEventListener('click', resetView);

    // Settings
    ui.colorPicker.addEventListener('input', e => State.color = e.target.value);
    document.getElementById('stroke-slider').addEventListener('input', e => { State.strokeWidth = parseInt(e.target.value); render(); });
    document.getElementById('opacity-slider').addEventListener('input', e => { State.opacity = parseFloat(e.target.value); render(); });
    document.getElementById('label-mode').addEventListener('change', e => { State.labelMode = e.target.value; render(); });
    document.getElementById('pattern-toggle').addEventListener('change', e => { State.patternMode = e.target.checked; render(); });
    document.getElementById('hold-draw-toggle').addEventListener('change', e => { State.drawBehavior = e.target.checked ? 'hold' : 'click'; });

    // Context Menu
    document.getElementById('ctx-sibling').addEventListener('click', addSibling);
    document.getElementById('ctx-delete-grp').addEventListener('click', deleteSelected);
    document.getElementById('ctx-delete-pt').addEventListener('click', deleteVertex);

    // Input
    ui.labelText.addEventListener('keydown', e => {
        if(e.key === 'Enter') commitLabel();
        if(e.key === 'Escape') cancelLabel();
    });

    // Drag & Drop
    document.body.addEventListener('dragover', e => e.preventDefault());
    document.body.addEventListener('drop', e => {
        e.preventDefault();
        if(e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]);
    });

    if(window.matchMedia('(prefers-color-scheme: dark)').matches) toggleTheme();
    
    renderLoop();
}

/**
 * --------------------------------------------------------------------------
 * PATTERN GENERATION
 * --------------------------------------------------------------------------
 */
function createPattern(color, index) {
    const key = color + index;
    if (patternCache[key]) return patternCache[key];

    const pCanvas = document.createElement('canvas');
    const pCtx = pCanvas.getContext('2d');
    const size = 20;
    pCanvas.width = size;
    pCanvas.height = size;

    pCtx.fillStyle = hexToRgba(color, 0.1);
    pCtx.fillRect(0, 0, size, size);

    pCtx.strokeStyle = color;
    pCtx.fillStyle = color;
    pCtx.lineWidth = 2;

    const type = index % 6;
    pCtx.beginPath();
    if (type === 0) { pCtx.moveTo(0, size); pCtx.lineTo(size, 0); }
    else if (type === 1) { pCtx.moveTo(0, 0); pCtx.lineTo(size, size); }
    else if (type === 2) { pCtx.moveTo(0, size/2); pCtx.lineTo(size, size/2); pCtx.moveTo(size/2, 0); pCtx.lineTo(size/2, size); }
    else if (type === 3) { pCtx.arc(size/2, size/2, 3, 0, Math.PI*2); pCtx.fill(); }
    else if (type === 4) { pCtx.moveTo(0, size/2); pCtx.lineTo(size, size/2); }
    else if (type === 5) { pCtx.moveTo(size/2, 0); pCtx.lineTo(size/2, size); }
    pCtx.stroke();

    const pattern = ctx.createPattern(pCanvas, 'repeat');
    patternCache[key] = pattern;
    return pattern;
}

/**
 * --------------------------------------------------------------------------
 * INPUT HANDLING
 * --------------------------------------------------------------------------
 */
function onMouseDown(e) {
    if (!State.image) return;
    
    // Pan Mode or Middle Click
    if (e.button === 1 || (State.tool === 'pan' && e.button === 0)) {
        // Check if hitting a label to drag
        const pt = getWorldPoint(e);
        const hitLabel = hitTestLabel(pt);
        
        if (hitLabel) {
            State.draggingLabel = hitLabel.id;
            container.style.cursor = 'move';
        } else {
            State.isPanning = true;
            State.lastMouse = { x: e.clientX, y: e.clientY };
            container.style.cursor = 'grabbing';
        }
        return;
    }

    if (e.button !== 0) return;

    const pt = getWorldPoint(e);

    // 1. Edit Vertex
    if (State.hoveredVertex) {
        State.draggingVertex = State.hoveredVertex;
        State.selectedGroupId = State.groups[State.hoveredVertex.groupId].id;
        updateLayerUI();
        return;
    }

    // 2. Insert Vertex (Only for Polygons)
    if (State.hoveredEdge && !State.isDrawing) {
        const { groupId, pathIdx, ptIdx } = State.hoveredEdge;
        const group = State.groups[groupId];
        if (group.type !== 'arrow') {
            group.paths[pathIdx].splice(ptIdx + 1, 0, pt);
            State.draggingVertex = { groupId, pathIdx, ptIdx: ptIdx + 1 };
            State.selectedGroupId = group.id;
            saveState();
            return;
        }
    }

    // 3. Drawing (Lasso or Arrow)
    if (State.tool === 'draw' || State.tool === 'arrow') {
        if (State.isDrawing) {
            // If in "Click" mode, add point
            if (State.drawBehavior === 'click') {
                const start = State.activePath[0];
                const dist = Math.hypot(pt.x - start.x, pt.y - start.y);
                const screenDist = dist * State.scale;

                if (State.tool === 'draw' && State.activePath.length > 2 && screenDist < Config.snapDist) {
                    finishPath();
                } else {
                    State.activePath.push(pt);
                    State.isDragging = true;
                }
            }
        } else {
            // Start New
            const hitGroup = findGroupHit(pt);
            if (hitGroup && !State.isDrawing && State.tool === 'draw') {
                State.selectedGroupId = hitGroup.id;
                updateLayerUI();
                render();
            } else {
                State.isDrawing = true;
                State.activePath = [pt];
                State.isDragging = true;
            }
        }
    }
}

function onMouseMove(e) {
    if (!State.image) return;
    const pt = getWorldPoint(e);

    if (State.isPanning) {
        const dx = e.clientX - State.lastMouse.x;
        const dy = e.clientY - State.lastMouse.y;
        State.panX += dx;
        State.panY += dy;
        State.lastMouse = { x: e.clientX, y: e.clientY };
        render();
        return;
    }

    if (State.draggingLabel) {
        const group = State.groups.find(g => g.id === State.draggingLabel);
        if (group) {
            group.labelPos = pt;
            render();
        }
        return;
    }

    if (State.draggingVertex) {
        const { groupId, pathIdx, ptIdx } = State.draggingVertex;
        State.groups[groupId].paths[pathIdx][ptIdx] = pt;
        render();
        return;
    }

    if (State.isDrawing && State.isDragging) {
        const last = State.activePath[State.activePath.length - 1];
        // For arrows, we want smooth updates, for lasso we filter slightly
        const threshold = State.tool === 'arrow' ? 0 : 2 / State.scale;
        
        if (Math.hypot(pt.x - last.x, pt.y - last.y) > threshold) {
            State.activePath.push(pt);
        }
        render();
        return;
    }

    updateHoverState(pt);
}

function onMouseUp(e) {
    State.isPanning = false;
    State.draggingLabel = null;
    container.style.cursor = State.tool === 'pan' ? 'grab' : 'crosshair';

    if (State.draggingVertex) {
        State.draggingVertex = null;
        saveState();
    }

    if (State.isDrawing && State.isDragging) {
        State.isDragging = false;
        
        // If "Hold to Draw" is active, finish immediately
        if (State.drawBehavior === 'hold') {
            finishPath();
        } else {
            // Click mode logic
            if (State.tool === 'arrow') {
                finishPath(); // Arrows always finish on release in click mode too usually, but let's stick to pattern
            } else {
                // Lasso Click Mode: Auto-close if near start
                const start = State.activePath[0];
                const end = State.activePath[State.activePath.length - 1];
                const dist = Math.hypot(end.x - start.x, end.y - start.y) * State.scale;
                if (State.activePath.length > 2 && dist < Config.snapDist) {
                    finishPath();
                }
            }
        }
    }
    render();
}

function onWheel(e) {
    if (!State.image) return;
    e.preventDefault();
    const zoomDir = e.deltaY > 0 ? -1 : 1;
    zoom(zoomDir, e.clientX, e.clientY);
}

function onKeyDown(e) {
    if (e.target.tagName === 'INPUT') return;
    
    if (e.code === 'Space') {
        if (!State.isPanning) {
            State.prevTool = State.tool;
            setTool('pan');
        }
    }
    if (e.key === 'Escape') {
        if (State.isDrawing) {
            State.isDrawing = false;
            State.activePath = [];
            render();
        } else {
            ui.ctxMenu.style.display = 'none';
        }
    }
    if (e.key === 'Enter' && State.isDrawing) finishPath();
    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
    if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
    if (e.key === 'Delete' || e.key === 'Backspace') deleteSelected();
    if (e.key === '[') { State.strokeWidth = Math.max(1, State.strokeWidth - 1); render(); }
    if (e.key === ']') { State.strokeWidth = Math.min(20, State.strokeWidth + 1); render(); }
}

function onKeyUp(e) {
    if (e.code === 'Space' && State.prevTool) {
        setTool(State.prevTool);
        State.prevTool = null;
    }
}

/**
 * --------------------------------------------------------------------------
 * LOGIC: DRAWING & EDITING
 * --------------------------------------------------------------------------
 */
function finishPath() {
    if (State.activePath.length < 2) {
        State.isDrawing = false;
        State.activePath = [];
        render();
        return;
    }

    // Process Path based on Tool
    let finalPath = State.activePath;
    
    if (State.tool === 'arrow') {
        // Smooth the arrow line
        finalPath = smoothPoints(State.activePath);
    } else {
        // Lasso: Close loop
        if (State.activePath.length > 2) {
            finalPath = simplifyPath(State.activePath, Config.simplifyEpsilon / State.scale);
            finalPath.push({ ...finalPath[0] });
        }
    }

    if (State.addingSiblingTo) {
        const group = State.groups.find(g => g.id === State.addingSiblingTo);
        if (group) {
            group.paths.push(finalPath);
            saveState();
            showStatus("Sibling area added");
        }
        State.addingSiblingTo = null;
        State.isDrawing = false;
        State.activePath = [];
        render();
    } else {
        State.activePath = finalPath; // Store for label commit
        showLabelInput();
    }
}

function showLabelInput() {
    // Position input at end of path or center
    let pos;
    if (State.tool === 'arrow') {
        pos = State.activePath[State.activePath.length - 1];
    } else {
        pos = getCentroid(State.activePath);
    }
    
    const screen = getScreenPoint(pos.x, pos.y);
    
    ui.floatInput.style.display = 'block';
    ui.floatInput.style.left = screen.x + 'px';
    ui.floatInput.style.top = screen.y + 'px';
    
    ui.labelText.value = `Object ${State.groups.length + 1}`;
    ui.labelText.focus();
    ui.labelText.select();
}

function commitLabel() {
    const label = ui.labelText.value.trim() || "Untitled";
    
    const nextColor = PALETTE[State.groups.length % PALETTE.length];
    State.color = nextColor;
    ui.colorPicker.value = nextColor;

    const newGroup = {
        id: Date.now().toString(),
        label: label,
        color: nextColor,
        type: State.tool === 'arrow' ? 'arrow' : 'poly',
        paths: [[...State.activePath]],
        labelPos: null // Auto position initially
    };
    
    State.groups.push(newGroup);
    State.selectedGroupId = newGroup.id;
    State.isDrawing = false;
    State.activePath = [];
    
    ui.floatInput.style.display = 'none';
    saveState();
    updateLayerUI();
    render();
}

function cancelLabel() {
    State.isDrawing = false;
    State.activePath = [];
    ui.floatInput.style.display = 'none';
    render();
}

function addSibling() {
    ui.ctxMenu.style.display = 'none';
    if (!State.selectedGroupId) return;
    State.addingSiblingTo = State.selectedGroupId;
    
    // Switch tool based on group type
    const group = State.groups.find(g => g.id === State.selectedGroupId);
    if (group.type === 'arrow') setTool('arrow');
    else setTool('draw');

    State.isDrawing = true;
    State.activePath = [];
    showStatus("Draw new area to add to group");
}

function deleteSelected() {
    if (!State.selectedGroupId) return;
    if (confirm("Delete selected group?")) {
        State.groups = State.groups.filter(g => g.id !== State.selectedGroupId);
        State.selectedGroupId = null;
        saveState();
        updateLayerUI();
        render();
    }
}

function deleteVertex() {
    ui.ctxMenu.style.display = 'none';
    if (State.hoveredVertex) {
        const { groupId, pathIdx, ptIdx } = State.hoveredVertex;
        const path = State.groups[groupId].paths[pathIdx];
        if (path.length > 2) {
            path.splice(ptIdx, 1);
            saveState();
            render();
        }
    }
}

/**
 * --------------------------------------------------------------------------
 * RENDERING
 * --------------------------------------------------------------------------
 */
function renderLoop() {
    requestAnimationFrame(renderLoop);
}

function render(targetCtx = ctx, isExport = false) {
    const w = isExport ? State.image.width : canvas.width;
    const h = isExport ? State.image.height : canvas.height;

    targetCtx.setTransform(1, 0, 0, 1, 0, 0);
    targetCtx.clearRect(0, 0, w, h);
    
    if (!isExport) {
        targetCtx.setTransform(State.scale, 0, 0, State.scale, State.panX, State.panY);
    }

    if (State.image) {
        targetCtx.drawImage(State.image, 0, 0);
    }

    // Draw Groups
    State.groups.forEach((group, index) => {
        const isSelected = !isExport && group.id === State.selectedGroupId;
        const scale = isExport ? 1 : State.scale;
        
        targetCtx.strokeStyle = isSelected ? '#fff' : group.color;
        targetCtx.lineWidth = (State.strokeWidth) / scale;

        // Draw Paths
        group.paths.forEach(path => {
            if (group.type === 'arrow') {
                drawArrow(targetCtx, path, group.color, isSelected, scale);
            } else {
                // Polygon
                let fillStyle;
                if (State.patternMode) fillStyle = createPattern(group.color, index);
                else fillStyle = hexToRgba(group.color, State.opacity);
                
                targetCtx.fillStyle = fillStyle;
                targetCtx.beginPath();
                targetCtx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) targetCtx.lineTo(path[i].x, path[i].y);
                targetCtx.closePath();
                targetCtx.fill();
                targetCtx.stroke();
            }

            // Vertices (Selected only)
            if (isSelected) {
                targetCtx.fillStyle = '#fff';
                const r = Config.vertexRadius / scale;
                for (let p of path) {
                    targetCtx.beginPath();
                    targetCtx.arc(p.x, p.y, r, 0, Math.PI*2);
                    targetCtx.fill();
                    targetCtx.stroke();
                }
            }
        });

        // Labels
        if (State.labelMode === 'inside' && group.paths.length > 0) {
            drawSmartLabel(targetCtx, group, isExport);
        }
    });

    // Legend
    if (State.labelMode === 'legend' && State.groups.length > 0) {
        drawLegend(targetCtx, isExport);
    }

    // Active Path
    if (!isExport && State.activePath.length > 0) {
        targetCtx.beginPath();
        targetCtx.moveTo(State.activePath[0].x, State.activePath[0].y);
        for (let i = 1; i < State.activePath.length; i++) targetCtx.lineTo(State.activePath[i].x, State.activePath[i].y);
        
        targetCtx.strokeStyle = State.color;
        targetCtx.lineWidth = State.strokeWidth / State.scale;
        targetCtx.stroke();

        if (State.tool === 'draw') {
            const start = State.activePath[0];
            targetCtx.beginPath();
            targetCtx.arc(start.x, start.y, (Config.snapDist / State.scale), 0, Math.PI*2);
            targetCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            targetCtx.fill();
        }
    }
}

function drawArrow(ctx, path, color, isSelected, scale) {
    if (path.length < 2) return;
    
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();

    // Arrowhead
    const end = path[path.length - 1];
    const prev = path[path.length - 2];
    const angle = Math.atan2(end.y - prev.y, end.x - prev.x);
    const headLen = 15 / scale;

    ctx.beginPath();
    ctx.moveTo(end.x, end.y);
    ctx.lineTo(end.x - headLen * Math.cos(angle - Math.PI / 6), end.y - headLen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(end.x - headLen * Math.cos(angle + Math.PI / 6), end.y - headLen * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
}

function drawSmartLabel(ctx, group, isExport) {
    const scale = isExport ? 1 : State.scale;
    
    // Determine Position
    let x, y;
    let isManual = false;

    if (group.labelPos) {
        x = group.labelPos.x;
        y = group.labelPos.y;
        isManual = true;
    } else {
        // Auto calc
        let path = group.paths[0]; // Use first path for simplicity
        if (group.type === 'poly') {
            const c = getCentroid(path);
            x = c.x; y = c.y;
        } else {
            // Arrow: Label at midpoint
            const mid = Math.floor(path.length / 2);
            x = path[mid].x; y = path[mid].y;
        }
    }

    ctx.font = `bold ${14 / scale}px sans-serif`;
    const text = group.label;
    const metrics = ctx.measureText(text);
    const padding = 6 / scale;
    const w = metrics.width + (padding * 2);
    const h = 24 / scale;

    // Check if small area (Auto-offset logic)
    let drawLine = isManual;
    if (!isManual && group.type === 'poly') {
        const bounds = getBounds(group.paths[0]);
        if ((bounds.maxX - bounds.minX) < w || (bounds.maxY - bounds.minY) < h) {
            // Too small, move outside
            x = bounds.maxX + w/2 + 10/scale;
            y = bounds.minY - 10/scale;
            drawLine = true;
        }
    }

    // Draw Leader Line
    if (drawLine) {
        const origin = group.type === 'poly' ? getCentroid(group.paths[0]) : group.paths[0][Math.floor(group.paths[0].length/2)];
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        ctx.lineTo(x, y);
        ctx.strokeStyle = group.color;
        ctx.lineWidth = 1 / scale;
        ctx.stroke();
        
        // Dot at origin
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, 3/scale, 0, Math.PI*2);
        ctx.fillStyle = group.color;
        ctx.fill();
    }

    // Box
    ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
    ctx.fillRect(x - w/2, y - h/2, w, h);
    ctx.strokeStyle = group.color;
    ctx.lineWidth = 1.5 / scale;
    ctx.strokeRect(x - w/2, y - h/2, w, h);

    // Text
    ctx.fillStyle = "#000";
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x, y);
}

function drawLegend(ctx, isExport) {
    const scale = isExport ? 1 : State.scale;
    const fontSize = 14 / scale;
    const padding = 10 / scale;
    const lineHeight = 24 / scale;
    const boxWidth = 150 / scale;
    const boxHeight = (State.groups.length * lineHeight) + (padding * 2);
    
    const x = State.image.width - boxWidth - (20 / scale);
    const y = 20 / scale;

    ctx.fillStyle = `rgba(255, 255, 255, ${State.opacity + 0.5})`;
    ctx.fillRect(x, y, boxWidth, boxHeight);
    ctx.strokeStyle = "#999";
    ctx.lineWidth = 1 / scale;
    ctx.strokeRect(x, y, boxWidth, boxHeight);

    ctx.font = `${fontSize}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    State.groups.forEach((g, i) => {
        const rowY = y + padding + (i * lineHeight) + (lineHeight/2) - (padding/2);
        const boxSize = 14 / scale;
        
        if (State.patternMode && g.type === 'poly') ctx.fillStyle = createPattern(g.color, i);
        else ctx.fillStyle = g.color;
        
        ctx.fillRect(x + padding, rowY - boxSize/2, boxSize, boxSize);
        ctx.strokeRect(x + padding, rowY - boxSize/2, boxSize, boxSize);

        ctx.fillStyle = "#000";
        ctx.fillText(g.label, x + padding + boxSize + (8/scale), rowY);
    });
}

/**
 * --------------------------------------------------------------------------
 * HELPERS
 * --------------------------------------------------------------------------
 */
function hitTestLabel(pt) {
    // Simple hit test for labels in Hand mode
    const scale = State.scale;
    const h = 24 / scale;
    
    for (let group of State.groups) {
        // Re-calculate label position logic to find hit box
        let x, y;
        if (group.labelPos) {
            x = group.labelPos.x; y = group.labelPos.y;
        } else {
            let path = group.paths[0];
            if (group.type === 'poly') {
                const c = getCentroid(path);
                x = c.x; y = c.y;
                // Check auto-offset logic
                ctx.font = `bold ${14 / scale}px sans-serif`;
                const w = ctx.measureText(group.label).width + 12/scale;
                const bounds = getBounds(path);
                if ((bounds.maxX - bounds.minX) < w || (bounds.maxY - bounds.minY) < h) {
                    x = bounds.maxX + w/2 + 10/scale;
                    y = bounds.minY - 10/scale;
                }
            } else {
                const mid = Math.floor(path.length / 2);
                x = path[mid].x; y = path[mid].y;
            }
        }
        
        // Approx width
        const w = (group.label.length * 8 + 20) / scale; 
        if (pt.x >= x - w/2 && pt.x <= x + w/2 && pt.y >= y - h/2 && pt.y <= y + h/2) {
            return group;
        }
    }
    return null;
}

function smoothPoints(points) {
    if (points.length < 3) return points;
    // Chaikin's Algorithm for smoothing
    let smoothed = [];
    smoothed.push(points[0]);
    for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[i];
        const p1 = points[i+1];
        smoothed.push({ x: 0.75 * p0.x + 0.25 * p1.x, y: 0.75 * p0.y + 0.25 * p1.y });
        smoothed.push({ x: 0.25 * p0.x + 0.75 * p1.x, y: 0.25 * p0.y + 0.75 * p1.y });
    }
    smoothed.push(points[points.length - 1]);
    return smoothed;
}

function getWorldPoint(e) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: (e.clientX - rect.left - State.panX) / State.scale,
        y: (e.clientY - rect.top - State.panY) / State.scale
    };
}

function getScreenPoint(wx, wy) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: (wx * State.scale) + State.panX + rect.left,
        y: (wy * State.scale) + State.panY + rect.top
    };
}

function updateHoverState(pt) {
    State.hoveredVertex = null;
    State.hoveredEdge = null;
    
    if (!State.selectedGroupId) return;
    
    const group = State.groups.find(g => g.id === State.selectedGroupId);
    if (!group) return;

    const hitDist = Config.hitRadius / State.scale;

    for (let i = 0; i < group.paths.length; i++) {
        const path = group.paths[i];
        for (let j = 0; j < path.length; j++) {
            if (Math.hypot(pt.x - path[j].x, pt.y - path[j].y) < hitDist) {
                State.hoveredVertex = { groupId: State.groups.indexOf(group), pathIdx: i, ptIdx: j };
                container.style.cursor = 'move';
                render();
                return;
            }
        }
    }

    // Edges (Poly only)
    if (group.type === 'poly') {
        for (let i = 0; i < group.paths.length; i++) {
            const path = group.paths[i];
            for (let j = 0; j < path.length; j++) {
                const p1 = path[j];
                const p2 = path[(j + 1) % path.length];
                const dist = distToSegment(pt, p1, p2);
                if (dist < hitDist) {
                    State.hoveredEdge = { groupId: State.groups.indexOf(group), pathIdx: i, ptIdx: j };
                    container.style.cursor = 'copy';
                    render();
                    return;
                }
            }
        }
    }
    
    container.style.cursor = State.tool === 'pan' ? 'grab' : 'crosshair';
    render();
}

function distToSegment(p, v, w) {
    const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
    if (l2 == 0) return Math.hypot(p.x - v.x, p.y - v.y);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
}

function findGroupHit(pt) {
    for (let i = State.groups.length - 1; i >= 0; i--) {
        const group = State.groups[i];
        for (let path of group.paths) {
            if (group.type === 'poly') {
                if (pointInPoly(pt, path)) return group;
            } else {
                // Arrow hit test (distance to line)
                for(let j=0; j<path.length-1; j++) {
                    if(distToSegment(pt, path[j], path[j+1]) < 5/State.scale) return group;
                }
            }
        }
    }
    return null;
}

function pointInPoly(p, vs) {
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        let xi = vs[i].x, yi = vs[i].y;
        let xj = vs[j].x, yj = vs[j].y;
        let intersect = ((yi > p.y) != (yj > p.y)) && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

function getCentroid(path) {
    let x = 0, y = 0;
    path.forEach(p => { x += p.x; y += p.y; });
    return { x: x / path.length, y: y / path.length };
}

function getBounds(path) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    path.forEach(p => {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
    });
    return { minX, minY, maxX, maxY, cx: (minX+maxX)/2, cy: (minY+maxY)/2 };
}

function simplifyPath(points, epsilon) {
    if (points.length <= 2) return points;
    let dmax = 0, index = 0;
    const end = points.length - 1;
    for (let i = 1; i < end; i++) {
        const d = distToSegment(points[i], points[0], points[end]);
        if (d > dmax) { index = i; dmax = d; }
    }
    if (dmax > epsilon) {
        const res1 = simplifyPath(points.slice(0, index + 1), epsilon);
        const res2 = simplifyPath(points.slice(index), epsilon);
        return res1.slice(0, res1.length - 1).concat(res2);
    }
    return [points[0], points[end]];
}

/**
 * --------------------------------------------------------------------------
 * FILE & EXPORT
 * --------------------------------------------------------------------------
 */
function loadFile(file) {
    if (!file.type.startsWith('image/')) return alert("Not an image");
    const reader = new FileReader();
    reader.onload = e => {
        const img = new Image();
        img.onload = () => {
            State.image = img;
            State.groups = [];
            State.history = [];
            resetView();
            ui.emptyState.style.display = 'none';
            updateLayerUI();
            render();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function exportJSON() {
    if (!State.image) return;
    const data = {
        version: "4.0",
        image: State.image.src.substring(0, 50) + "...",
        width: State.image.width,
        height: State.image.height,
        annotations: State.groups.map(g => ({
            label: g.label,
            color: g.color,
            type: g.type,
            points: g.paths,
            labelPos: g.labelPos
        }))
    };
    const jsonBlob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
    const url = URL.createObjectURL(jsonBlob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "annotations.json";
    a.click();
}

function exportImage() {
    if (!State.image) return;
    const tCanvas = document.createElement('canvas');
    tCanvas.width = State.image.width;
    tCanvas.height = State.image.height;
    const tCtx = tCanvas.getContext('2d');
    render(tCtx, true);
    const link = document.createElement('a');
    link.download = 'annotated_image.png';
    link.href = tCanvas.toDataURL('image/png');
    link.click();
}

/**
 * --------------------------------------------------------------------------
 * UI UPDATES & UTILS
 * --------------------------------------------------------------------------
 */
function updateLayerUI() {
    ui.layerList.innerHTML = '';
    State.groups.slice().reverse().forEach(g => {
        const el = document.createElement('div');
        el.className = `layer-item ${g.id === State.selectedGroupId ? 'selected' : ''}`;
        el.innerHTML = `
            <div class="layer-dot" style="background:${g.color}"></div>
            <div class="layer-name">${g.label}</div>
            <div style="font-size:0.7rem; color:var(--text-muted)">${g.type === 'arrow' ? '‚Üó' : '‚¨†'}</div>
        `;
        el.onclick = () => {
            State.selectedGroupId = g.id;
            updateLayerUI();
            render();
        };
        el.oncontextmenu = (e) => {
            e.preventDefault();
            State.selectedGroupId = g.id;
            updateLayerUI();
            onContextMenu(e);
        };
        ui.layerList.appendChild(el);
    });
}

function onContextMenu(e) {
    e.preventDefault();
    ui.ctxMenu.style.display = 'flex';
    ui.ctxMenu.style.left = e.clientX + 'px';
    ui.ctxMenu.style.top = e.clientY + 'px';
}

function zoom(dir, cx, cy) {
    const factor = dir > 0 ? (1 + Config.zoomStep) : (1 - Config.zoomStep);
    const newScale = Math.max(Config.minZoom, Math.min(Config.maxZoom, State.scale * factor));
    
    const rect = canvas.getBoundingClientRect();
    const mx = cx !== undefined ? cx - rect.left : rect.width / 2;
    const my = cy !== undefined ? cy - rect.top : rect.height / 2;

    State.panX = mx - (mx - State.panX) * (newScale / State.scale);
    State.panY = my - (my - State.panY) * (newScale / State.scale);
    State.scale = newScale;
    
    render();
}

function resetView() {
    if (!State.image) return;
    const rect = container.getBoundingClientRect();
    const scaleW = rect.width / State.image.width;
    const scaleH = rect.height / State.image.height;
    State.scale = Math.min(scaleW, scaleH) * 0.9;
    State.panX = (rect.width - State.image.width * State.scale) / 2;
    State.panY = (rect.height - State.image.height * State.scale) / 2;
    render();
}

function resizeCanvas() {
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    render();
}

function setTool(t) {
    State.tool = t;
    document.querySelectorAll('.btn-icon').forEach(b => b.classList.remove('active'));
    document.getElementById(`tool-${t}`).classList.add('active');
    container.style.cursor = t === 'pan' ? 'grab' : 'crosshair';
}

function toggleTheme() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    document.documentElement.setAttribute('data-theme', isDark ? 'light' : 'dark');
    document.getElementById('theme-btn').textContent = isDark ? 'üåô' : '‚òÄ';
}

function showStatus(msg) {
    ui.statusBar.textContent = msg;
    ui.statusBar.classList.add('show');
    setTimeout(() => ui.statusBar.classList.remove('show'), 2000);
}

function saveState() {
    const snapshot = JSON.stringify(State.groups);
    if (State.historyIdx < State.history.length - 1) {
        State.history = State.history.slice(0, State.historyIdx + 1);
    }
    State.history.push(snapshot);
    State.historyIdx++;
    if (State.history.length > 20) { State.history.shift(); State.historyIdx--; }
    localStorage.setItem('lassoData', snapshot);
}

function undo() {
    if (State.historyIdx > 0) {
        State.historyIdx--;
        State.groups = JSON.parse(State.history[State.historyIdx]);
        updateLayerUI();
        render();
        showStatus("Undo");
    }
}

function redo() {
    if (State.historyIdx < State.history.length - 1) {
        State.historyIdx++;
        State.groups = JSON.parse(State.history[State.historyIdx]);
        updateLayerUI();
        render();
        showStatus("Redo");
    }
}

function clearAll() {
    if(confirm("Clear all annotations?")) {
        State.groups = [];
        saveState();
        updateLayerUI();
        render();
    }
}

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// Start
init();

</script>
</body>
</html>
